\section{\MakeTextUppercase{АНАЛИЗ ПРЕДМЕТНОЙ ОБЛАСТИ}}
\subsection{Алгоритмы нахождения кратчайших путей}

Задачей нахождения кратчайшего пути является поиск оптимального и короткого пути между двумя точками. Решения этой задачи в большинстве случаев основаны на алгоритме Дейкстры для нахождения кратчайшего пути в взвешенных графах. 

Простейшие алгоритмы для обхода графа, такие как поиск в ширину и поиск в глубину могут найти какой-то путь от начальной до конечной вершины, но не учитывают стоимость пути. Одним из первых алгоритмов поиска пути с учётом его стоимости был алгоритм Беллмана -- Форда, который проходит по всем возможным маршрутам и находит наиболее оптимальный, вследствие чего имеет временную сложность $O(|V||E|)$, где $V$ - количество вершин, а $E$ - количество рёбер. Однако для нахождения пути близкого к оптимальному не обязательно перебирать все пути, а можно отсекать неперспективные направления на основе некой эвристики, что может дать таким алгоритмам нижнюю оценку $O(|E|\log(|V|))$. Такими алгоритмами являются алгоритм Дейкстры, A* и их модификации.

\subsubsection{A*}

Алгоритм A{*} (A звёздочка) - это алгоритм общего назначения, который может быть использован для решения многих задач, например для нахождения путей. A{*} является вариацией алгоритма Дейкстры и используя эвристическую функция для ускорения работы, при этом гарантируя наиболее эффектное использование онной. 

Алгоритм A{*} поочерёдно рассматривает наиболее перспективные неисследованные точки или точки с неоптимальным маршрутом до них, выбирая пути которые минимизируют $ f(n) = g(n) + h(n) $, где $n$ последняя точка в пути, $g(n)$ - стоимость пути от начальной точки до точки $n$, а $h(n)$ - эвристическая оценка стоимости пути от $n$ до конца пути. Когда точка исследована, алгоритм останавливается если это конечная точка, иначе все её соседи добавляются в список для дальнейшего исследования.

Для нахождения пути от начальной до конечной точки, кроме стоимости пути до точки, следует записывать и её предка (точку из которой мы пришли в неё).

%\begin{algorithm}
%    \caption{Псевдокод A*}\label{alg:a-star-example}
%    \begin{algorithmic}[1]
%        \State Добавляем начальную точку в открытый список.
%        \Repeat
%        \State Поиск точки из открытого списка с наименьшим значением функции f.
%        \State Добавить точку в закрытый список.
%        \ForAll{точек соседних текущей}
%        \If{точка входит в закрытый список}
%        \State Игнорировать её.
%        \ElsIf{точка не в открытом списке}
%        \State Добавляем точку в открытый список. 
%        \State Делаем текущую точку предком этой точки. 
%        \State Подсчитываем её параметры.
%        \Else
%        \If{возможно ли улучшить длину пути через неё} 
%        \State Меняем её предка и пересчитываем параметры.
%        \EndIf
%        \EndIf
%        \EndFor
%        \Until Конечная точка не добавлена в закрытый список и открытый список не пуст.
%    \end{algorithmic}
%\end{algorithm}

Свойства алгоритма A*:

\begin{enumerate}
    \item Алгоритм гарантирует нахождение пути между точками, если он существует;
    \item Если эвристическая функция $h(n)$ не переоценивает действительную минимальную стоимость пути, то алгоритм работает наиболее оптимально;
    \item A* оптимально эффективен для заданной эвристики $h(n)$.
\end{enumerate}

На оценку сложности A* влияет использованная эвристика, в худшем случае количество точек рассмотренных A* экспоненциально растёт по сравнению с длинной пути, однако при эвристике $h(n)$ удовлетворяющей условию $|h(x) - h^*(x)| \leq O(\log h^*(x))$, где $h^*(n)$ - оптимальная эвристика, алгоритм будет иметь полиномиальную сложность. Так же на временную сложность влияет выбранный способ хранения закрытых и открытых точек.

\underline{Оценка памяти}

\subsubsection{JPS}



\subsubsection{HPA* и HAA*}

HPA* (Hierarchical Path-Finding A*) - добавляет алгоритму A* иерархическую абстракцию, разбивая карту на прилегающие друг к другу кластеры, которые соединены входами. Одной из основных идей алгоритма является то, что расчёт пути в A* каждый раз происходит с нуля, что можно исправить добавив сохранение кратчайших путей между определёнными точками. 

Первым этапом алгоритма является препроцессинг карты для построения кластеров и их входов. При этом возможно построение нескольких уровней графа кластеров используя один и тот же алгоритм рекурсивно на созданных во время предыдущего прохода кластерах.

Во время исполнения программы запрос нахождения пути выполняется рекурсивно находя и уточняя путь на графе начиная с самых крупного уровня кластеров. После нахождения пути может применятся его сглаживание.

Алгоритм HPA* работает с такими допущениями:

\begin{enumerate}
    \item Все актёры имеют одинаковый размер, при этом все части навигационной сетки проходимы ими;
    \item На всех участках карты агенты имеют одинаковую проходимость.
\end{enumerate}

Иерархическая структура карты сильно ускоряет поиск пути, однако алгоритм HPA* работает не учитывая такие важные параметры как размер агентов и проходимость местности.  

В итоге размер агентов и проходимость карты должны учитываться при нахождении пути, что в случае с алгоритмом HPA* приводит к тому, что эти параметры должны учитываться при оценки путей между входами.

Алгоритм иерархического поиска является достаточно абстрактным для учёта указанных проблем. Для этого на основе алгоритма HPA* был создан алгоритм HAA* (Hierarchical Annotated A*), который при создании путей между входами кластера учитывает размеры атёров и проходимость местности.

Основная разница с алгоритмом HPA* у алгоритма HAA* состоит в шаге формирования пути между транзитными точками в рамках кластера и дальнейшем шаге их оптимизации. При нахождении пути между транзитными точками в кластере следует найти пути для всех агентов разных размеров и проходимости 

В итоге алгоритм HAA* имеет такие же преимущества как HPA*, а так же возможность учёта размера агента и проходимости карты. В зависимости от выбранной тактики устранения похожих путей между транзитными точками кластеров конечный путь будет хуже оптимального до 4-8\%.

По сравнению с JPS алгоритмы HPA* и HAA*, работают дольше и являются намного сложнее в реализации, которая может быть несоразмерна с полученной от них выгодой, однако они могут выдавать начальные участки пути намного быстрее чем JPS и A*, что в некоторых случаях оправдывает их написание.

Для реализации в выпускной работе были выбраны алгоритмы A* и JPS.  

\subsection{Различные представления области поиска}



\subsection{Эвристические функции}



\subsection{Постановка задачи}

Целью выпускной работы является проведение анализа существующих алгоритмов поиска путей, разработка различных вариантов алгоритмов и их оптимизаций, создание оптимизированной универсальной библиотеки для нахождения оптимальных маршрутов и анализ полученных результатов. Создание библиотеки состоит из заданий:

\begin{enumerate}
    \item анализ алгоритмов нахождения путей;
    \item разработка алгоритма A*;
    \item разработка алгоритма JPS;
    \item разработка препроцессинга GoalBounding;
    \item интеграция GoalBounding в алгоритм A*;
    \item интеграция GoalBounding в алгоритм JPS;
    \item разработка визуализатора для наглядной оценки и проверки алгоритмов;
    \item создание модуля для сравнения и валидации алгоритмов;
\end{enumerate}

Для написания библиотеки был выбран язык C++. Для визуализации результатов была выбрана библиотека SFML и SFGUI. Для использования параллельности - библиотека threadpool11.