\section[Анализ предметной области]{\MakeTextUppercase{АНАЛИЗ ПРЕДМЕТНОЙ ОБЛАСТИ}}
\subsection{Алгоритмы нахождения кратчайших путей}

Задачей нахождения кратчайшего пути является поиск оптимального и короткого пути между двумя точками. Решения этой задачи в большинстве случаев основаны на алгоритме Дейкстры \cite{Dijkstra} для нахождения кратчайшего пути в взвешенных графах. 

Простейшие алгоритмы для обхода графа, такие как поиск в ширину и поиск в глубину могут найти какой-то путь от начальной до конечной вершины, но не учитывают стоимость пути. Одним из первых алгоритмов поиска пути с учётом его стоимости был алгоритм Беллмана -- Форда, который проходит по всем возможным маршрутам и находит наиболее оптимальный, вследствие чего имеет временную сложность $O(|V||E|)$, где $V$ - количество вершин, а $E$ - количество рёбер. Однако для нахождения пути близкого к оптимальному не обязательно перебирать все пути, а можно отсекать неперспективные направления на основе некой эвристики, что может дать таким алгоритмам нижнюю оценку $O(|E|\log(|V|))$. Такими алгоритмами являются алгоритм Дейкстры, A* и их модификации.

\subsubsection{A*}

Алгоритм A{*} (A звёздочка) - это алгоритм общего назначения, который может быть использован для решения многих задач, например для нахождения путей. A{*} является вариацией алгоритма Дейкстры и используя эвристическую функция для ускорения работы, при этом гарантируя наиболее эффектное использование онной \cite{A_STAR}. 

Алгоритм A{*} поочерёдно рассматривает наиболее перспективные неисследованные точки или точки с неоптимальным маршрутом до них, выбирая пути которые минимизируют $ f(n) = g(n) + h(n) $, где $n$ последняя точка в пути, $g(n)$ - стоимость пути от начальной точки до точки $n$, а $h(n)$ - эвристическая оценка стоимости пути от $n$ до конца пути. Когда точка исследована, алгоритм останавливается если это конечная точка, иначе все её соседи добавляются в список для дальнейшего исследования.

Для нахождения пути от начальной до конечной точки, кроме стоимости пути до точки, следует записывать и её предка (точку из которой мы пришли в неё).

%\begin{algorithm}
%    \caption{Псевдокод A*}\label{alg:a-star-example}
%    \begin{algorithmic}[1]
%        \State Добавляем начальную точку в открытый список.
%        \Repeat
%        \State Поиск точки из открытого списка с наименьшим значением функции f.
%        \State Добавить точку в закрытый список.
%        \ForAll{точек соседних текущей}
%        \If{точка входит в закрытый список}
%        \State Игнорировать её.
%        \ElsIf{точка не в открытом списке}
%        \State Добавляем точку в открытый список. 
%        \State Делаем текущую точку предком этой точки. 
%        \State Подсчитываем её параметры.
%        \Else
%        \If{возможно ли улучшить длину пути через неё} 
%        \State Меняем её предка и пересчитываем параметры.
%        \EndIf
%        \EndIf
%        \EndFor
%        \Until Конечная точка не добавлена в закрытый список и открытый список не пуст.
%    \end{algorithmic}
%\end{algorithm}

Свойства алгоритма A*:

\begin{enumerate}
    \item Алгоритм гарантирует нахождение пути между точками, если он существует;
    \item Если эвристическая функция $h(n)$ не переоценивает действительную минимальную стоимость пути, то алгоритм работает наиболее оптимально;
    \item A* оптимально эффективен для заданной эвристики $h(n)$.
\end{enumerate}

На оценку сложности A* влияет использованная эвристика, в худшем случае количество точек рассмотренных A* экспоненциально растёт по сравнению с длинной пути, однако при эвристике $h(n)$ удовлетворяющей условию $|h(x) - h^*(x)| \leq O(\log h^*(x))$, где $h^*(n)$ - оптимальная эвристика, алгоритм будет иметь полиномиальную сложность. Так же на временную сложность влияет выбранный способ хранения закрытых и открытых точек.

\subsubsection{JPS}

Jump Point Search (JPS) - эффективная техника для нахождения и отброса симметричных путей \cite{IMPROVING_JPS}. JPS представляет собой модификацию алгоритма A* с двумя правилами отброса точек. Применения этих правил позволяет увеличить производительность поиска путей на квадратной сетки на порядок - без препроцессинга и дополнительной памяти.

JPS действует в предположении, что прохождение по клеткам карты намного быстрее добавления их в открытые и закрытые списки. При этом одна клетка может рассматриваться много раз в течении одного поиска.

В JPS существует два набора правил: правила отброса клеток и правила прыжков.

Имея клетку $x$, достижимую из родительской клетки $p$, мы отбрасываем из соседей $x$ любую клетку $n$ для которой исполняется хотя бы одно из условий:

\begin{enumerate}
	\item существует путь от $p$ до $n$ равный $\pi'=(p,x,n)$ строго короче чем путь от $p$ до $n$ через клетку $x$ равный $\pi=(p,x,n)$;
	\item существует путь от $p$ до $n$ равный $\pi'=(p,n)$ такой же длины как путь от $p$ до $n$ через клетку $x$ равный $\pi=(p,x,n)$, но путь $\pi'$ имеет диагональное перемещение раньше чем путь $\pi$. 
\end{enumerate}

Для вычисления каждого из правил достаточно проверки только соседей данной точки.  



Преимуществами JPS является отсутствие препроцессинга, отсутствие дополнительного потребления памяти, постоянное ускорение A* на порядок. Главным недостатком является, то что он работает только на картах с одинаковой стоимостью прохода по клеткам, однако существует теоретическое решение данной проблемы, но любое её решение приводит к уменьшение преимущества JPS над простым A*.

\subsubsection{HPA* и HAA*}

HPA* (Hierarchical Path-Finding A*) - добавляет алгоритму A* иерархическую абстракцию, разбивая карту на прилегающие друг к другу кластеры, которые соединены входами \cite{HPA}. Одной из основных идей алгоритма является то, что расчёт пути в A* каждый раз происходит с нуля, что можно исправить добавив сохранение кратчайших путей между определёнными точками. 

Первым этапом алгоритма является препроцессинг карты для построения кластеров и их входов. При этом возможно построение нескольких уровней графа кластеров используя один и тот же алгоритм рекурсивно на созданных во время предыдущего прохода кластерах.

Во время исполнения программы запрос нахождения пути выполняется рекурсивно находя и уточняя путь на графе начиная с самых крупного уровня кластеров. После нахождения пути может применятся его сглаживание.

Алгоритм HPA* работает с такими допущениями:

\begin{enumerate}
    \item Все актёры имеют одинаковый размер, при этом все части навигационной сетки проходимы ими;
    \item На всех участках карты агенты имеют одинаковую проходимость.
\end{enumerate}

Иерархическая структура карты сильно ускоряет поиск пути, однако алгоритм HPA* работает не учитывая такие важные параметры как размер агентов и проходимость местности.  

В итоге размер агентов и проходимость карты должны учитываться при нахождении пути, что в случае с алгоритмом HPA* приводит к тому, что эти параметры должны учитываться при оценки путей между входами.

Алгоритм иерархического поиска является достаточно абстрактным для учёта указанных проблем. Для этого на основе алгоритма HPA* был создан алгоритм HAA* (Hierarchical Annotated A*), который при создании путей между входами кластера учитывает размеры актёров и проходимость местности.

Основная разница с алгоритмом HPA* у алгоритма HAA* состоит в шаге формирования пути между транзитными точками в рамках кластера и дальнейшем шаге их оптимизации. При нахождении пути между транзитными точками в кластере следует найти пути для всех агентов разных размеров и проходимости 

В итоге алгоритм HAA* имеет такие же преимущества как HPA*, а так же возможность учёта размера агента и проходимости карты. В зависимости от выбранной тактики устранения похожих путей между транзитными точками кластеров конечный путь будет хуже оптимального до 4-8\%.

\subsection{Различные представления области поиска}

Для поиска пути требуется некоторое представление области поиска, от его выбора зависит скорость работы алгоритма, точность его работы и качество пути. Так же выбор способа представления влияет на занимаемое областью место в оперативной памяти. 

Глобально пространства поиска можно разделить на дискретные и непрерывные, далее бдут рассматриваться только дискретные пространства (для непрерывных пространств существуют алгоритмы сведения их к дискретным).  

Сожно выделить такие способы представления: квадратная сетка, quadtree (дерево квадрантов), navmesh (навигационная сетка), waypoints (путевые точки).

\subsubsection{Квадратная сетка}

Квадратная сетка является самым простым и очевидным представлением области поиска. Подходит для игр жанра TD (tower defence) и некоторых RTS игр. 

Обладает такими преимуществами: проста в использовании и представлении в памяти, можно быстро и легко добавлять и удалять препятствия, легко поддерживать различную проходимость карты и различные размеры агентов. 

К недостаткам можно отнести большое занимаемое в памяти место, сложность поддержки многоуровневых карт а так же наименьшую скорость работы алгоритма A* с данным представлением. 

Некоторые алгоритмы поиска путей не работают на других представлениях кроме квадратной сетки, например JPS.

\subsubsection{Quadtree (дерево квадрантов)}

Дерево квадрантов является усовершенствованной версией квадратной сетки. Позволяет сильно уменьшить занимаемое место за счёт объединения одинаковых участков, так же позволяет ускорить алгоритм поиска пути. Минусом можно считать усложнение добавления и удаления элементов из карты.

\subsubsection{Navmesh (навигационная сетка)}

Навигационная сетка - набор выпуклых многоугольников, которые описывают проходимую часть трёхмерного мира. 

Является популярной техникой для описания трёхмерных карт. Навигационная сетка часто автоматически генерируется из трёхмерного мира, однако при этом возникает проблема оптимизации числа полигонов для ускорения работы поиска путей и уменьшении веса сетки.

Преимуществами навигационной сетки являются: возможность представить многоуровневый мир, низкое потребление памяти, скорость поиска пути, точность. Недостатком является сложность динамического изменения мира.

\subsubsection{Waypoints (путевые точки)}

Путевые точки - набор точек и рёбер по которым можно ходить. Обычно создаются вручную.

Преимущества: просты в использовании, возможно описать пути любой сложности ( в воздухе, в воде и т.д.), простота изменения, гибкость работы.

Недостатки: медленней чем навигационная сетка, пути выходят хуже (более длинные и неестественные).

\subsection{Эвристические функции}

Эвристическая функция $h(n)$ вычисляет для алгоритмов поиска путей основанных на A* приблизительную стоимость маршрута от точки до цели. Эвристика может использоваться для контролирования поведения алгоритмов \cite{HEURISTICS}:

\begin{enumerate}
	\item если $h(n)$ равно нулю, то A* вырождается алгоритм Дейкстры;
	\item если $h(n)$ всегда меньше или равен стоимости пути от точки до цели, то A* гарантирует нахождение кратчайшего пути, однако чем больше разница между $h(n)$ и реальной стоимостью, тем больше точек раскрывает алгоритм и тем медленней работает;
	\item если $h(n)$ равен стоимости пути от точки до цели, то A* следует только по оптимальному пути, что делает его очень быстрым, однако такая эвристика невозможна в общих случаях;
	\item если $h(n)$ переоценивает стоимость пути, то A* не гарантирует нахождение кратчайшего пути, однако это может ускорить его;
	\item если $h(n)$ очень сильно переоценивает стоимость пути, то алгоритм вырождается в жадный.
\end{enumerate}

Исходя из этого можно сделать вывод, что при выборе эвристики осуществляется выбор между скоростью и точностью.

Что бы получить эвристику, которая всегда равна стоимости от точки до цели, нужно предрасчитать пути между каждыми парами точек, что не осуществимо на реальных картах. Однако существует некоторые упрощения и модификации этой эвристики:

\begin{enumerate}
	\item покрыть карту более крупной сеткой и уже для неё рассчитывать данную эвристику;
	\item выделить некоторые путевые точки и рассчитывать эвристику между ними;
	\item сохранять не все расстояния от точки до остальных, а только по одной области для каждого направления, содержащие все точки до которых оптимальный путь идёт в выбранном направлении (Goal Bounding).
\end{enumerate}

Для различных представлений области поиска существуют разные эвристики. Для области представленной квадратной сеткой можно выделить такие эвристики:

\begin{enumerate}
	\item расстояние городских кварталов (Manhattan distance) - расстояние равное сумме модулей разностей координат точек $|x_1 - x_2| + |y_1-y_2|$;
	\item евклидова метрика (Euclidean distance) - равна расстоянию между точками вычисленному по теореме пифагора $\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}$;
	\item эвристики препятствующие прохождению по путям с одинаковой стоимостью (Tie breaaking).
\end{enumerate} 

\subsection{Goal Bounding}

Goal Bounding - техника отброса заранее неподходящих точек, которая позволяет значительно ускорить поиск пути \cite{GOAL_BOUNDING}. Goal Bounding можно разделить на два этапа:

\begin{enumerate}
	\item оффлайн этап - представляет собой препроцессинг карты с целью найти и сохранить прямоугольники для каждого из направлений, ограничивающие минимальную область на карте, которая включает в себя все точки карты до которых путь через выбранное направление является самым оптимальным.
	\item онлайн этап - прекращение итераций в выбранном направлении если целевая точка не входит в его ограничивающий прямоугольник.
\end{enumerate}
 
Данная техника применима для всех областей поиска и для всех алгоритмов поиска. Её недостатком является время препроцессинга и занимаемое место результирующими данными. Препроцессинг работает за $O(n^2)$, где $n$ - количество узлов на карте, что делает невозможным пересчёт во время исполнения программы. Количество занимаемой памяти - линейно и для квадратной сетки с 8 направлениями равно $ 4 * 32 * n$ байт.

Этап препроцессинга легко поддаётся распараллеливанию, что позволяет работать даже с большими картами, имея достаточное количество вычислительной мощности.  

\subsection{Выбор алгоритма и представления области поиска}

Выбор алгоритма сильно зависит от выбранного типа области поиска, в данной выпускной работе была выбрана область поиска представленная квадратной сеткой. Нахождения пути на ней является самым затратным по производительности, поэтому оптимизация алгоритмов работающих с этим представлением является актуальной задачей. 

Как базовый алгоритм был взят A*. По сравнению с JPS алгоритмы HPA* и HAA*, работают дольше и являются намного сложнее в реализации, которая может быть несоразмерна с полученной от них выгодой, однако они могут выдавать начальные участки пути намного быстрее чем JPS и A*, что в некоторых случаях оправдывает их написание. В данной работе был выбран алгоритм JPS.  


\subsection{Постановка задачи}

Целью выпускной работы является проведение анализа существующих алгоритмов поиска путей, разработка различных вариантов алгоритмов и их оптимизаций, создание оптимизированной универсальной библиотеки для нахождения оптимальных маршрутов в контексте игровых приложений и анализ полученных результатов. 

Создание библиотеки состоит из заданий:

\begin{enumerate}
    \item анализ алгоритмов нахождения путей;
    \item разработка алгоритма A*;
    \item разработка алгоритма JPS;
    \item разработка препроцессинга Goal Bounding;
    \item интеграция Goal Bounding в алгоритм A*;
    \item интеграция Goal Bounding в алгоритм JPS;
    \item разработка удобного визуализатора для наглядной оценки и проверки алгоритмов;
    \item создание модуля для сравнения и валидации алгоритмов;
\end{enumerate}

Для написания библиотеки был выбран язык C++. Для визуализации результатов была выбрана библиотека SFML и SFGUI. Для написания параллельных алгоритмов - библиотека threadpool11, которая реализует пул потоков.