\section[Анализ результатов]{\MakeTextUppercase{АНАЛИЗ РЕЗУЛЬТАТОВ}}

\subsection{Сравнительный анализ алгоритмов}

Сравнительный анализ алгоритмов проводился на картах из таких игр: ``Dragon Age: Origins'', ``Warcraft III'', ``Baldurs Gate II ''.  	

\addtikz{Зависимость длительности одного вызова A* от стоимости пути для карты AR0011SR (512x512)}{a_star_relation_path_to_call_time}
{
			\begin{axis}[
				name=plot1,
				xlabel={Стоимость пути},
				ylabel={миллисекунды},
				legend pos=north west]
				\addplot[smooth,mark=*,black] plot coordinates {
					(0,0.448063862068965517)
					(30,0.472433033333333333)
					(60,0.527812393258426966)
					(90,0.599805262626262626)
					(120,0.841127683544303797)
					(150,1.0553257948717949)
					(180,1.3920127872340426)
					(210,2.2239329)
					(240,2.3867776153846154)
					(270,3.0294784)
					(300,3.8465792625)
				};
				\legend{A*}
			\end{axis}
			
				\begin{axis}[
					name=plot3,
					at=(plot1.below south east), anchor=above north east,
					xlabel={Стоимость пути},
					ylabel={миллисекунды},
					legend pos=north west]
					\addplot[smooth,mark=*,black] plot coordinates {
						(0,0.594149576470588235  )
						(30,0.611748366666666667 )
						(60,0.644259606741573034 )
						(90,0.683271989795918367 )
						(120,0.7361247875        )
						(150,0.757007987179487179)
						(180,0.862117212765957447)
						(210,0.974048076923076923)
						(240,1.1305644945054945)
						(270,1.3967989125      )
						(300,1.5073147974683544)
					};
					\legend{AStar+GB}
				\end{axis} 
			
			
			\begin{axis}[
				name=plot4,
				at=(plot3.right of north east), anchor=left of north west,
				xlabel={Стоимость пути},
				ylabel={микросекунды},
				ytick scale label code/.code={},
				scaled y ticks=base 10:3,
				legend pos=north west]
				\addplot[smooth,mark=*,black] plot coordinates {
					(0,0.015908358208955224  )
					(30,0.02028479012345679  )
					(60,0.023223315068493151 )
					(90,0.025253605263157895 )
					(120,0.029929679487179487)
					(150,0.033295310810810811)
					(180,0.036215545454545455)
					(210,0.037474287671232877)
					(240,0.045864765432098765)
					(270,0.04933508219178822 )
					(300,0.05579805)
				};
				\legend{JPS+GB}
			\end{axis} 
			
			\begin{axis}[
				name=plot2,
				at=(plot4.above north west), anchor=below south west,
				xlabel={Стоимость пути},
				ylabel={микросекунды},
				ytick scale label code/.code={},
				scaled y ticks=base 10:3,
				legend pos=north west]
				\addplot[smooth,mark=*,black] plot coordinates {
					(0,0.047480657142857143)
					(30,0.058619259259259259)
					(60,0.081039013333333333)
					(90,0.084907064935064935)
					(120,0.100879714285714286)
					(150,0.12847427397260274)
					(180,0.130261075949367089)
					(210,0.134091986486486486)
					(240,0.186503316455696203)
					(270,0.20989638961038961)
					(300,0.236634461538461538)
				};
				\legend{JPS}
			\end{axis} 

}

\subsection{Возможные дальнейшие улучшения}

В ходе выполнения работы были рассмотрены, реализованы и проанализированы несколько алгоритмов: A*, JPS, A* + Goal Bounding, JPS + Goal Bounding. В процессе чего были так же найдены и рассмотрены модификации и улучшения представленных алгоритмов, которые не вошли в данную работу. Ниже рассмотрены некоторые из них.

Одним из недостатков алгоритма JPS является то, что он работает только на картах с одинаковой стоимостью прохождения по клеткам. Однако в играх часто имеется потребность в неоднородных картах, что исключает использование данного алгоритма без дополнительных модификаций. В качестве модификации для поддержки неоднородных карт может быть рассмотрено следующие предположение: если на однородной карте вынужденные соседи возникали когда клетку преграждало препятствие, то на неоднородной карте как препятствие можно так же рассматривать смену стоимости прохождения через клетку. При этом если стоимости прохождения по клеткам для соседних клеток в большинстве случаев различны, то JPS теряет своё преимущество перед A*. Для исправления такой ситуации можно уменьшить разрешение стоимости пути, что бы у соседних клеток чаще была одинаковая стоимость. Или ввести некоторую адаптивную дельту если разность стоимости пути между клетками меньше её, то они считаются одинаковыми. Данная модификация является чисто теоретической, так как никем не была реализована на практике.

Алгоритм Goal Bounding позволяет существенно ускорить A* и JPS, однако при этом часть препроцессинга выполняется очень долго, результат занимает много места и не поддерживает изменение карты во время выполнения. Эти недостатки сильно сужают применимость данного алгоритма. Одним из решений может являться расчёт границ не для всех клеток на карте, а только для некоторых линий, которые могут быть определены как ограничивающие или преграждающие некоторую область. В результате скорость расчёта сильно увеличится, однако при этом увеличится и время поиска пути. Так же открытым является вопрос -- существует ли алгоритм расчёта с более оптимальной асимптотикой.

В алгоритме JPS ключевой частью является скорость сканирования карты для нахождения препятствий. Эту операцию можно ускорить посредством анализа не одной клетки а линии из нескольких клеток за раз -- используя то, что карту можно представить как битовую матрицу, где 0 -- это отсутствие препятствия, а 1 -- его наличие. Используя такую организацию карты можно значительно уменьшить количество чтений из памяти и количество выполнений условных операторов. Для нахождения тупика можно использовать битовую операцию ffs (find first set), которая существует на большинстве платформах и возвращает позицию первого бита равного 1. Для нахождения вынужденных соседей требуется считать по одной линии выше и ниже текущей, вынужденный сосед появляется когда за препятствием идёт свободная клетка, что для линии можно проверить простой операцией $f(L)\ =\ (L<<1)\ \&\ !L$. При этом при помощи команды ffs можно получить место потенциального вынужденного соседа и сравнить с имеющимся тупиком на текущей линии. Так же отдельная проверка для того, что бы не пропустить цель.

Для JPS кроме Goal Bounding имеет смысл другой алгоритм препроцессинга карты - нахождение прыжковых точек для горизонтальных, вертикальных и диагональных прыжков. Такой препроцессинг очень быстр, так как в отличии от Goal Bounding ему не надо для каждой клетки исследовать всю карту и в следствии чего может выполнятся сразу при изменении карты, при чём возможно изменение информации лишь для части клеток карты.
