\section[Анализ результатов и тестирование]{\MakeTextUppercase{АНАЛИЗ РЕЗУЛЬТАТОВ И ТЕСТИРОВАНИЕ}}

\subsection{Сравнительный анализ алгоритмов}

Сравнительный анализ алгоритмов проводился на картах из таких игр: ``Dragon Age: Origins'', ``Warcraft III'', ``Baldurs Gate II''. Для выполнения анализа были взяты карты и пути с сайта ``movingai.com/benchmarks/'', где собраны подготовленные наборы данных состоящие из карт и сценариев к ним. В ходе сравнительного анализа было использовано 267 различных карт: 36 из ``Warcraft III'', 156 из ``Dragon Age: Origins'' и 75 из ``Baldurs Gate II''. Количество протестированных путей в общей сложности составило 1070000. Для Astar и JPS без модификации Goal Bounding было протестировано больше путей чем с данной модификацией, так как карты с размерностью более 512 на 512 были исключены из препроцессинга. На картах с большим размером время препроцессинга оказывалось очень большим.

Тестирование алгоритмов проводилось на компьютере со следующими характеристиками: процессором AMD FX-8320 с частотой 3.5 ghz и оперативной памятью 16gb DDR3 1333 mhz. Программа выполнялась под операционной системой Windows 10 без каких-либо запущенных сторонних процессов. Программа для тестирования была скомпилирована с ключом O3 компилятором g++ версии 5.3.  

В ходе анализа алгоритмов было получено более миллиона уникальных векторов данных, которые первоначально записывались в файл с форматом csv, однако для последующего анализа они были импортированы в реляционную базу данных PostgreSQL, что сильно упростило манипуляцию с данными.

Рассмотрим результаты выполнения алгоритмов на карте AR0011SR размером 512 на 512 \cref{fig:a_star_alg_cmp_AR0011SR}.

\addtikz{Сравнение алгоритмов на карте AR0011SR}{a_star_alg_cmp_AR0011SR}{1}
{
	\begin{axis}[
		name=plot1,
		xlabel={Стоимость пути},
		ylabel={миллисекунды},
		ymode=log,
		log ticks with fixed point,
		legend pos=outer north east]
		\addplot[smooth,mark=*,black] plot coordinates {
			(0,0.450337827586206897 )
			(30,0.473905788888888889)
			(60,0.526151056179775281)
			(90,0.603534767676767677)
			(120,0.859617405063291139)
			(150,1.0536403333333333  )
			(180,1.3990839574468085  )
			(210,2.2270172111111111  )
			(240,2.3663113736263736  )
			(270,3.01304575          )
			(300,3.848451175         )
			(330,4.4758353296703297  )
			(360,5.6996502413793103  )
			(390,6.27858416          )
			(420,7.6057240178571429  )
			(450,8.6096742142857143  )
		};
		\addplot[smooth,mark=square*,black] plot coordinates {
			(0,0.446724137931034483  )
			(30,0.446576022222222222 )
			(60,0.457549224719101124 )
			(90,0.491480683673469388 )
			(120,0.5109110625        )
			(150,0.529025333333333333)
			(180,0.593930297872340426)
			(210,0.651347263736263736)
			(240,0.724399197802197802)
			(270,0.8862859           )
			(300,0.928384075949367089)
			(330,0.858660098901098901)
			(360,0.995955793103448276)
			(390,1.0348355866666667)
			(420,1.251526363636364 )
			(450,1.8444414666666667)
		};
		\addplot[dotted,mark=*,mark options={solid},black] plot coordinates {
			(0,0.012311942857142857  )
			(30,0.015875864197530864 )
			(60,0.01732458904109589  )
			(90,0.01950175           )
			(120,0.023366141025641026)
			(150,0.025258567567567568)
			(180,0.027953415584415584)
			(210,0.029131767123287671)
			(240,0.036167641975308642)
			(270,0.038806767123287671)
			(300,0.04332785          )
			(330,0.048559086956521739)
			(360,0.049925911392405063)
			(390,0.054420759036144578)
			(420,0.0565024           )
			(450,0.050475512195121951)
			(480,0.07050855)
			(510,0.084748  )
		};
		\addplot[dashed,mark=square*,mark options={solid},black] plot coordinates {
			(0,0.055721971428571429  )
			(30,0.068408641975308642 )
			(60,0.09245564           )
			(90,0.097469831168831169 )
			(120,0.117343753246753247)
			(150,0.148138506849315068)
			(180,0.146065987341772152)
			(210,0.153351256756756757)
			(240,0.209265075949367089)
			(270,0.234806376623376623)
			(300,0.267204269230769231)
			(330,0.323374849315068493)
			(360,0.364171797297297297)
			(390,0.502699630952380952)
			(420,0.533060150684931507)
			(450,0.622631926829268293)
			(480,0.704095943396226415)
			(510,0.639205)
		};
		\legend{A*,A*+GB,JPS+GB,JPS}
	\end{axis} 	
}

 Самой быстрой является комбинация алгоритма JPS и Goal Bounding, при этом время выполнения одного вызова варьировалось от 12 до 80 микросекунд. Время выполнения JPS варьировалось от 55 до 700 микросекунд, что в 3-10 раз хуже чем с Goal Bounding \cref{fig:a_star_relation_path_to_call_time}. A* с и без Goal Bounding на коротких путях показывают примерно одинаковое время. На длинных путях модификация Goal Bounding даёт преимущество в несколько раз (в 3-5 раз). Время выполнения A* доходит до 9 миллисекунд, что для игровых приложений очень долго, так как это время близко ко времени полной отрисовки кадра, а найти может потребоваться больше одного пути.

\addtikz{Зависимость длительности одного вызова поиска пути от его стоимости для карты AR0011SR (512x512)}{a_star_relation_path_to_call_time}{1}
{
			\begin{axis}[
				name=plot1,
				xlabel={Стоимость пути},
				ylabel={миллисекунды},
				legend pos=north west]
				\addplot[smooth,mark=*,black] plot coordinates {
			(0,0.450337827586206897 )
			(30,0.473905788888888889)
			(60,0.526151056179775281)
			(90,0.603534767676767677)
			(120,0.859617405063291139)
			(150,1.0536403333333333  )
			(180,1.3990839574468085  )
			(210,2.2270172111111111  )
			(240,2.3663113736263736  )
			(270,3.01304575          )
			(300,3.848451175         )
			(330,4.4758353296703297  )
			(360,5.6996502413793103  )
			(390,6.27858416          )
			(420,7.6057240178571429  )
			(450,8.6096742142857143  )
				};
				\legend{A*}
			\end{axis}
			
				\begin{axis}[
					name=plot3,
					at=(plot1.below south east), anchor=above north east,
					xlabel={Стоимость пути},
					ylabel={миллисекунды},
					legend pos=north west]
					\addplot[smooth,mark=*,black] plot coordinates {
			(0,0.446724137931034483  )  
			(30,0.446576022222222222 )
			(60,0.457549224719101124 )
			(90,0.491480683673469388 )
			(120,0.5109110625        )
			(150,0.529025333333333333)
			(180,0.593930297872340426)
			(210,0.651347263736263736)
			(240,0.724399197802197802)
			(270,0.8862859           )
			(300,0.928384075949367089)
			(330,0.858660098901098901)
			(360,0.995955793103448276)
			(390,1.0348355866666667)
			(420,1.251526363636364 )
			(450,1.8444414666666667)
					};
					\legend{A*+GB}
				\end{axis} 
			
			
			\begin{axis}[
				name=plot4,
				at=(plot3.right of north east), anchor=left of north west,
				xlabel={Стоимость пути},
				ylabel={микросекунды},
				ytick scale label code/.code={},
				scaled y ticks=base 10:3,
				legend pos=north west]
				\addplot[smooth,mark=*,black] plot coordinates {
			(0,0.012311942857142857  )
			(30,0.015875864197530864 )
			(60,0.01732458904109589  )
			(90,0.01950175           )
			(120,0.023366141025641026)
			(150,0.025258567567567568)
			(180,0.027953415584415584)
			(210,0.029131767123287671)
			(240,0.036167641975308642)
			(270,0.038806767123287671)
			(300,0.04332785          )
			(330,0.048559086956521739)
			(360,0.049925911392405063)
			(390,0.054420759036144578)
			(420,0.0565024           )
			(450,0.050475512195121951)
			(480,0.07050855)
			(510,0.084748  )
				};
				\legend{JPS+GB}
			\end{axis} 
			
			\begin{axis}[
				name=plot2,
				at=(plot4.above north west), anchor=below south west,
				xlabel={Стоимость пути},
				ylabel={микросекунды},
				ytick scale label code/.code={},
				scaled y ticks=base 10:3,
				legend pos=north west]
				\addplot[smooth,mark=*,black] plot coordinates {
			(0,0.055721971428571429  )
			(30,0.068408641975308642 )
			(60,0.09245564           )
			(90,0.097469831168831169 )
			(120,0.117343753246753247)
			(150,0.148138506849315068)
			(180,0.146065987341772152)
			(210,0.153351256756756757)
			(240,0.209265075949367089)
			(270,0.234806376623376623)
			(300,0.267204269230769231)
			(330,0.323374849315068493)
			(360,0.364171797297297297)
			(390,0.502699630952380952)
			(420,0.533060150684931507)
			(450,0.622631926829268293)
			(480,0.704095943396226415)
			(510,0.639205)
				};
				\legend{JPS}
			\end{axis} 

}

На разных картах алгоритмы могут вести себя по разному \cref{fig:a_star_alg_cmp_brc501d}. В случае карты brc501d алгоритм JPS в большинстве случаев медленней чем комбинация A* и Goal Bounding, хотя всё равно остаётся намного быстрей обычного A*. В данном случае карта имеет такое строение, что многие пути имеют вид ``крюков'' огибающих очень длинное препятствие, в таком случае алгоритм JPS сканирует очень много клеток и хотя в открытый список добавляются немногие из них, большое количество клеток проходится безрезультатно. На рисунке \ref{fig:jps_degradation} показан такой случай - непроходимые клетки обозначены чёрным цветом, красная ломаная показывает найденный путь, а сине-зелёные полоски показывают направления в которых проходил алгоритм JPS. Как можно заметить для нахождения пути алгоритму пришлось пройти всю карту больше одного раза.

\addtikz{Сравнение алгоритмов на карте brc501d}{a_star_alg_cmp_brc501d}{1}
{
	\begin{axis}[
		name=plot1,
		xlabel={Стоимость пути},
		ylabel={миллисекунды},
		ymode=log,
		log ticks with fixed point,
		legend pos=outer north east]
		\addplot[smooth,mark=*,black] plot coordinates {
			(0,0.052029395348837209 )
			(30,0.085476139534883721)
			(60,0.185111410526315789)
			(90,0.453184678571428571)
			(120,0.857330337078651685)
			(150,1.2929210119047619  )
			(180,1.7794124285714286  )
			(210,2.179155            )
			(240,2.9767070625        )
			(270,3.4637211012658228  )
			(300,4.4178079117647059  )
			(330,4.6648257654320988  )
			(360,5.8247307653061224  )
			(390,5.8970600810810811  )
			(420,5.9309958255813953  )
			(450,5.8462961219512195  )
			(480,6.5784044444444444  )
		};
		\addplot[smooth,mark=square*,black] plot coordinates {
			(0,0.046492755813953488  )
			(30,0.056089627906976744 )
			(60,0.068674452631578947 )
			(90,0.085188905882352941 )
			(120,0.100951609195402299)
			(150,0.106980767441860465)
			(180,0.152424012048192771)
			(210,0.201235827586206897)
			(240,0.2231119375        )
			(270,0.326703936708860759)
			(300,0.341250617647058824)
			(330,0.400953475         )
			(360,0.570358858585858586)
			(390,0.525511561643835616)
			(420,0.379954482352941176)
			(450,0.522641047619047619)
			(480,1.1540081111111111)			
		};
		\addplot[dotted,mark=*,mark options={solid},black] plot coordinates {
			(0,0.00695063157894736842)
			(30,0.00875052           )
			(60,0.010565513157894737 )
			(90,0.0143075            )
			(120,0.016939310810810811)
			(150,0.019650253164556962)
			(180,0.023864923076923077)
			(210,0.025602753246753247)
			(240,0.029741623376623377)
			(270,0.036766671428571429)
			(300,0.038822779220779221)
			(330,0.053536639534883721)
			(360,0.07151592          )
			(390,0.082788410256410256)
			(420,0.09895061038961039 )
			(450,0.101980703703703704)
			(480,0.102642347222222222)
			(510,0.1125517)	
		};
		\addplot[dashed,mark=square*,mark options={solid},black] plot coordinates {
			(0,0.022047896103896104  )
			(30,0.02765783950617284  )
			(60,0.037216481012658228 )
			(90,0.073302469879518072 )
			(120,0.102604518987341772)
			(150,0.139790822784810127)
			(180,0.243236886075949367)
			(210,0.337014340909090909)
			(240,0.467919648648648649)
			(270,0.809973689189189189)
			(300,0.826181576923076923)
			(330,1.3658433209876543)
			(360,1.5994925949367089)
			(390,2.1918648243243243)
			(420,2.2828751756756757)
			(450,2.1450382469135802)
			(480,1.8008605466666667)
			(510,2.4253436176470588)
		};
		\legend{A*,A*+GB,JPS+GB,JPS}
	\end{axis} 	
}

\addimg{img/jps_degradation.png}{0.6}{Неоптимальность обхода карты brc501d алгоритмом JPS}{jps_degradation}



Таблица \ref{table:overall_alg_comparison} показывает абсолютную и относительную скорость алгоритмов в зависимости от длины пути. В таблице приведены значения продолжительности вызова одного запроса на нахождение пути в миллисекундах, так же продолжительность в процентах от алгоритма A*.

\addtable{Сравнение скорости выполнения алгоритмов на всех картах}{overall_alg_comparison}{
	\begin{tabular}{|l|c|c|c|c|c|c|c|}
		\hline
Стоимость& A* мс & A* + GB мс& \% от A* & JPS мс& \% от A*& JPS+GB мс& \% от A* \\
\hline 	
000	& 0,365	& 0,160	& 43,80\%	& 0,024	& 06,50\%	& 0,005 & 01,28\% \\
\hline
030	& 0,494	& 0,252	& 51,09\%	& 0,050	& 10,19\%	& 0,010 & 01,97\% \\
\hline
060	& 0,488	& 0,284	& 58,10\%	& 0,065	& 13,33\%	& 0,012 & 02,45\% \\
\hline
090	& 0,569	& 0,312	& 54,87\%	& 0,084	& 14,81\%	& 0,014 & 02,49\% \\
\hline
120	& 0,722	& 0,337	& 46,63\%	& 0,103	& 14,27\%	& 0,016 & 02,27\% \\
\hline
150	& 0,912	& 0,366	& 40,13\%	& 0,122	& 13,43\%	& 0,018 & 02,01\% \\
\hline
180	& 1,166	& 0,395	& 33,87\%	& 0,150	& 12,84\%	& 0,021 & 01,76\% \\
\hline
210	& 1,466	& 0,430	& 29,29\%	& 0,179	& 12,23\%	& 0,023 & 01,54\% \\
\hline
240	& 1,782	& 0,462	& 25,93\%	& 0,205	& 11,48\%	& 0,025 & 01,38\% \\
\hline
270	& 2,177	& 0,494	& 22,67\%	& 0,240	& 11,03\%	& 0,027 & 01,25\% \\
\hline
300	& 2,635	& 0,534	& 20,28\%	& 0,275	& 10,43\%	& 0,029 & 01,12\% \\
\hline
330	& 3,148	& 0,559	& 17,77\%	& 0,320	& 10,15\%	& 0,032 & 01,01\% \\
\hline
360	& 3,745	& 0,581	& 15,53\%	& 0,358	& 09,57\%	& 0,033 & 00,89\% \\
\hline
390	& 4,361	& 0,578	& 13,24\%	& 0,418	& 09,58\%	& 0,035 & 00,81\% \\
\hline
420	& 4,855	& 0,549	& 11,31\%	& 0,481	& 09,90\%	& 0,039 & 00,80\% \\
\hline
450	& 4,935	& 0,470	& 09,51\%	& 0,502	& 10,18\%	& 0,039 & 00,79\% \\
\hline
480	& 4,971	& 0,417	& 08,38\%	& 0,569	& 11,44\%	& 0,040 & 00,81\% \\
\hline
510	& 5,093	& 0,466	& 09,16\%	& 0,775	& 15,23\%	& 0,044 & 00,87\% \\
\hline
540	& 5,320	& 0,453	& 08,52\%	& 0,828	& 15,56\%	& 0,050 & 00,93\% \\
\hline
	\end{tabular}
	}

Исходя из приведённой таблицы можно сделать такие выводы:

\begin{enumerate}
	\item A* всегда медленней других алгоритмов;
	\item Goal Bounding больше ускоряет JPS чем A*;
	\item A* с Goal Bounding на длинных путях сравним и выигрывает по скорости JPS;
	\item JPS с Goal Bounding является самый быстрым алгоритмом и выполняется в от 50 до 100 раз быстрее чем A*; 
\end{enumerate}

Исходя из проведённого анализа временных характеристик алгоритмов можно предложить следующие рекомендации по их использованию в зависимости от карты:

\begin{enumerate}
	\item если карта имеет одинаковую проходимость клеток, на всём протяжении работы приложения остаётся неизменной и память устройства позволяет использовать Goal Bounding -- наилучшим выбором будет JPS с Goal Bounding;
	\item при неизменной карте с одинаковой проходимостью клеток, но ограниченной памятью, например на смартфоне, при больших картах лучше выбрать алгоритм JPS, хотя на картах с небольшим размером, менее 256x256, можно рекомендовать включить Goal Bounding;
	\item при неизменной карте с разной стоимость прохождения по клеткам -- алгоритм JPS не применим, в этом случае подойдёт A* с включённым Goal bounding (на устройствах с ограниченной памятью Goal Bounding имеет смысл отключить);
	\item если карта изменяется в процессе работы приложения и имеет различную проходимость клеток, то единственным выбором из рассмотренных алгоритмов является A*, так же возможным выбором может стать алгоритмы HAA* и RSR, рассмотренные при анализе алгоритмов.
\end{enumerate}

\subsection{Тестирование}

В ходе выполнения работы было проведено тестирование алгоритмов входящих в разрабатываемую библиотеку. 

Тестирование программного обеспечения -- проведение проверки соответствия между полученным и ожидаемым поведением программы, выполненное на ограниченном наборе тестов.

При тестировании применялось как ручное, так и автоматизированное тестирование. Ручное тестирование проводилось посредством визуализатора, который может загружать различные карты и выводить отладочную информацию о найденных путях.

Для автоматизированного тестирования была написана программа для запуска сценариев с заданными координатами начала и конца пути с его ожидаемой стоимостью, при выполнении которых ожидаемая стоимость пути сравнивалась с полученной.

В результате были исправлены выявленные ошибки и установленно, что алгоритмы работают корректно.

\subsection{Возможные дальнейшие улучшения}

В ходе выполнения работы были рассмотрены, реализованы и проанализированы несколько алгоритмов: A*, JPS, A* + Goal Bounding, JPS + Goal Bounding. В процессе чего были так же найдены и рассмотрены модификации и улучшения представленных алгоритмов, которые не вошли в данную работу. Ниже рассмотрены некоторые из них.

Одним из недостатков алгоритма JPS является то, что он работает только на картах с одинаковой стоимостью прохождения по клеткам. Однако в играх часто имеется потребность в неоднородных картах, что исключает использование данного алгоритма без дополнительных модификаций. В качестве модификации для поддержки неоднородных карт может быть рассмотрено следующие предположение: если на однородной карте вынужденные соседи возникали когда клетку преграждало препятствие, то на неоднородной карте как препятствие можно так же рассматривать смену стоимости прохождения через клетку. При этом если стоимости прохождения по клеткам для соседних клеток в большинстве случаев различны, то JPS теряет своё преимущество перед A*. Для исправления такой ситуации можно уменьшить разрешение стоимости пути, что бы у соседних клеток чаще была одинаковая стоимость. Или ввести некоторую адаптивную дельту если разность стоимости пути между клетками меньше её, то они считаются одинаковыми. Данная модификация является чисто теоретической, так как никем не была реализована на практике.

Алгоритм Goal Bounding позволяет существенно ускорить A* и JPS, однако при этом часть препроцессинга выполняется очень долго, результат занимает много места и не поддерживает изменение карты во время выполнения. Эти недостатки сильно сужают применимость данного алгоритма. Одним из решений может являться расчёт границ не для всех клеток на карте, а только для некоторых линий, которые могут быть определены как ограничивающие или преграждающие некоторую область. В результате скорость расчёта сильно увеличится, однако при этом увеличится и время поиска пути. Так же открытым является вопрос -- существует ли алгоритм расчёта с более оптимальной асимптотикой.

В алгоритме JPS ключевой частью является скорость сканирования карты для нахождения препятствий. Эту операцию можно ускорить посредством анализа не одной клетки а линии из нескольких клеток за раз -- используя то, что карту можно представить как битовую матрицу, где 0 -- это отсутствие препятствия, а 1 -- его наличие. Используя такую организацию карты можно значительно уменьшить количество чтений из памяти и количество выполнений условных операторов. Для нахождения тупика можно использовать битовую операцию ffs (find first set), которая существует на большинстве платформах и возвращает позицию первого бита равного 1. Для нахождения вынужденных соседей требуется считать по одной линии выше и ниже текущей, вынужденный сосед появляется когда за препятствием идёт свободная клетка, что для линии можно проверить простой операцией $f(L)\ =\ (L<<1)\ \&\ !L$. При этом при помощи команды ffs можно получить место потенциального вынужденного соседа и сравнить с имеющимся тупиком на текущей линии. Так же отдельная проверка для того, что бы не пропустить цель.

Для JPS кроме Goal Bounding имеет смысл другой алгоритм препроцессинга карты -- нахождение прыжковых точек для горизонтальных, вертикальных и диагональных прыжков. Такой препроцессинг очень быстр, так как в отличии от Goal Bounding ему не надо для каждой клетки исследовать всю карту и в следствии чего может выполнятся сразу при изменении карты, при чём возможно изменение информации лишь для части клеток карты.

Для изменяемых во время выполнения карт может подойти алгоритм RSR, который даёт примерно такое же ускорение как и Goal Bounding, однако не может работать на картах с разной стоимостью прохождения по клеткам. Данный алгоритм может работать как с A*, так и теоретически с алгоритмом JPS.