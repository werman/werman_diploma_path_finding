\section[Описание программной реализации]{\MakeTextUppercase{ОПИСАНИЕ ПРОГРАММНОЙ РЕАЛИЗАЦИИ}}

\vspace{1\baselineskip} 

При реализации библиотеки и визуализатора возникли задачи не связанные с реализацией самих алгоритмов, такие как: корректное измерение времени работы алгоритмов и включение отдельных методов в зависимости от типа с которым работает алгоритм.

Для корректного измерение времени был создан класс MeasureUtils, который включает в себя методы для измерения скорости работы обычных функций и методов классов. Данные методы являются шаблонными, что позволяет добиться их универсальности. Они принимают настройки тестирования, которые содержат количество вызовов функции для прогрева и количество вызовов для измерения скорости, так же передаётся сама функция и её аргументы. Прогрев нужен что бы данные и инструкции гарантировано оказались в кэше процессора, чем уменьшили влияние времени на пересылку данных из оперативной памяти и кэшей нижнего уровня. Время выполнения функции равно общему времени выполнения её в цикле поделённому на количество итераций в цикле.

Включение и выключение методов в данной работе требуется для работы со знаковы и беззнаковыми целыми типами - для беззнаковых типов не требуется проверка на то, является ли переменная отрицательной, что нужно для проверки находится ли точка в границах карты. Данная проблемы решена двумя макросами  ``PF\_FUN\_ENABLE\_IF\_SIGNED'' и ``PF\_FUN\_ENABLE\_IF\_UNSIGNED'' \cref{fig:enable_fun_macro}.

\addimg{img/enable_fun_macro.png}{1}{Макросы для включения методов}{enable_fun_macro}

\subsection{Реализации алгоритма A*}

Алгоритм A* является базовым и наиболее часто используемым алгоритмом для поиска путей. Для работы алгоритм использует открытый и закрытый список. В открытый список добавляется начальная точка, открытый список содержит точки, которые мы уже нашли, но ещё не рассмотрели. После чего пока в открытом списке существуют точки -- выбирается точка с наименьшей стоимостью и рассматриваются её соседи. Если стоимость пути через данную точку до соседа меньше записанной в него стоимости, то стоимость пути до него изменяется и его родитель меняется на текущую клетку \cref{fig:a_star_open_list_add}. После рассмотрения точки - она добавляется в закрытый список. Если открытый список оказался пуст -- значит пути до конечной точки не существует. Если из открытого списка была взята конечная точка - это означает, что путь существует и можно реконструировать его. Для этого мы берём родителя конечной точки и рекурсивно рассматриваем её родителей в массив, пока не дойдём до начальной точки \cref{fig:a_star_reconstruct_path}.

\addimg{img/a_star_open_list_add.png}{1}{Добавление в открытый список в A*}{a_star_open_list_add}

\addimg{img/a_star_reconstruct_path.png}{1}{Реконструкция пути}{a_star_reconstruct_path}

При написании A* для открытого списка была использована очередь с приоритетом std::priority\_queue, а для закрытого списка - вектор имеющий размер карты. Такая реализация закрытого списка дала возможность делать проверку на вхождение в него за константное время. Память для закрытого списка выделяется один раз при создании экземпляра алгоритма поиска и при каждом поиске у всех клеток сбрасывается флаг посещённости.

\subsection{Реализация алгоритма JPS}

Алгоритм JPS представляет собой усовершенствование алгоритма A*. Недостатком A* является то, что он добавляет в открытый список все клетки, которые являются прямыми соседями рассматриваемой, , однако JPS предоставляет возможность пропуска добавления многих клеток на основе возможной симметрии путей.

Для пропуска добавления клеток JPS использует функции прыжков, которые делятся на горизонтальные, вертикальные и диагональные.

Логика работы горизонтального и вертикального прыжка одинакова. Рассмотрим горизонтальный прыжок враво - остальные варианты происходят по аналогии с ним. При этом мы можем сделать следующие допущения \cite{JPS_DETAILS}:

\begin{enumerate}
    \item клетка из который мы пришли может быть проигнорирована;
    \item клетки по диагонали позади рассматриваемой, мы тоже может игнорировать, так как они были достигнуты из родительской клетки;
    \item клетки выше и ниже рассматриваемой могут быть достигнуты оптимальнее из её родителя;
    \item клетки правее и выше/ниже рассматриваемой могут быть достигнуты оптимальнее из клеток на одну левее;
\end{enumerate}

Эти допущения приводят к тому что алгоритм должен рассматривать только клетки правее от текущий пока путь не содержит препятствий. Однако путь не всегда свободен от препятствий, что ломает приведённой допущение. Это происходит в том случае, когда клетка сверху или снизу рассматриваемой является препятствием, что делает утверждение о том, что оптимальный путь до диагональной клетки не проходит через рассматриваемую. В такой ситуации прыжок останавливается и клетка по диагонали и текущая клетка добавляются в открытый список для дальнейшего рассмотрения. 

Последним допущением является то, что если при прыжке препятствие блокирует продвижение в заданном направлении - весь прыжок может быть отброшен.

Такие же правила и допущения применимы для диагональных прыжков.

При диагональных прыжках при каждом смене клетки в заданном направлении происходит горизонтальный и вертикальный прыжок в стороны.

Когда прыжок закончен берётся клетка с наименьшим весом из открытого списка и из неё происходит прыжок в направлении в котором алгоритм пришёл в неё.

\subsection{Реализация и интеграция GoalBounds}

Алгоритм Goal Bounding можно разделить на два этапа: этап препроцессинга и проверка направления во время выполнения поиска пути. Во время препроцессинга происходит прохождение по всем клеткам карты, для каждой клетки выполняет волновой алгоритм, который заполняет все клетки стоимостью путей до них от начальной клетки и изначальным направлением по которому алгоритм пришёл в данную клетку. После чего для данной клетки определяется 8 ограничивающих прямоугольников \cref{fig:goal_bounding_dbg}, по одному на каждое направление \cref{fig:goal_bounding_fill}. Определяются они по такому алгоритму: 

\begin{enumerate}
	\item делаем минимальную точку прямоугольника равную координатам правой верхней точки карты, а максимальную - равной левой нижней;
	\item идём по всем точкам и расширяем прямоугольник соответствующий направлению в котором точка была достигнута из начальной, что бы прямоугольник включал её. 
\end{enumerate}

\addimg{img/goal_bounding_fill.png}{1}{Определение ограничивающих прямоугольников}{goal_bounding_fill}

\addimg{img/goal_bounding_dbg.png}{0.8}{Часть карты с раскрашенными разные цвета ограничивающими прямоугольниками}{goal_bounding_dbg}

Так как алгоритм вычисляет ограничивающие прямоугольники для каждой клетки независимо, то его можно распараллелить. Для этого был использован пул поток, реализованный библиотекой threadpool11. Для каждой клетки создаётся своя задача и добавляется в очередь, после добавления всех задач происходит ожидание их завершения. Каждый поток имеет свою карту для волнового алгоритма которая создаётся один раз для одного потока.

Для включения Goal Bounding в A* требуется добавить проверку на правильность направления сразу после проверки на вхождение точки в границу карты при итерировании по соседям текущей точки \cref{fig:a_star_test_goal_bounds}. 

Для добавления Goal Bouding в JPS требуется провести аналогичное действие, но для всех функций прыжков.

\addimg{img/a_star_test_goal_bounds.png}{1}{Проверка Goal Bounds}{a_star_test_goal_bounds}

\subsection{Реализация визуализатора}

Для реализации визуализатора была взята кроссплатформенная библиотека SFML. Визуализатор загружает карту и отрисовывает её на текстуру, которую в последствии отображает. Пути и отладочная информация алгоритмов отрисовывается так же на текстуры и впоследствии накладывается в определённом порядке на карту. Направления прыжков для алгоритма JPS отрисовываются простыми линиями.

Для нахождения координат клетки под указателем была создана функция ``get\_tile\_under\_mouse'', которая по канвасу для отрисовки и координатам указателя находит координаты клетки. 

Визуализатор, кроме отображения путей с отладочной информацией имеет возможность сравнивать скорость выполнения алгоритмов для выбранного пути.