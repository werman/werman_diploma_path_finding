\section[Описание программной реализации]{\MakeTextUppercase{ОПИСАНИЕ ПРОГРАММНОЙ РЕАЛИЗАЦИИ}}

\vspace{1\baselineskip} 

При реализации библиотеки и визуализатора возникли задачи не связанные с реализацией самих алгоритмов, такие как: корректное измерение времени работы алгоритмов и включение отдельных методов в зависимости от типа с которым работает алгоритм.

Для корректного измерение времени был создан класс MeasureUtils, который включает в себя методы для измерения скорости работы обычных функций и методов классов. Данные методы являются шаблонными, что позволяет добиться их универсальности. Они принимают настройки тестирования, которые содержат количество вызовов функции для прогрева и количество вызовов для измерения скорости, так же передаётся сама функция и её аргументы. Прогрев нужен что бы данные и инструкции гарантировано оказались в кэше процессора, чем уменьшили влияние времени на пересылку данных из оперативной памяти и кэшей нижнего уровня. Время выполнения функции равно общему времени выполнения её в цикле поделённому на количество итераций в цикле.

Включение и выключение методов в данной работе требуется для работы со знаковы и беззнаковыми целыми типами - для беззнаковых типов не требуется проверка на то, является ли переменная отрицательной, что нужно для проверки находится ли точка в границах карты. Данная проблемы решена двумя макросами  ``PF\_FUN\_ENABLE\_IF\_SIGNED'' и ``PF\_FUN\_ENABLE\_IF\_UNSIGNED'' \cref{fig:enable_fun_macro}.

\addimg{img/enable_fun_macro.png}{1}{Макросы для включения методов}{enable_fun_macro}

\subsection{Реализации алгоритма A*}

Алгоритм A* является базовым и наиболее часто используемым алгоритмом для поиска путей. Для работы алгоритм использует открытый и закрытый список. В открытый список добавляется начальная точка, открытый список содержит точки, которые мы уже нашли, но ещё не рассмотрели. После чего пока в открытом списке существуют точки -- выбирается точка с наименьшей стоимостью и рассматриваются её соседи. Если стоимость пути через данную точку до соседа меньше записанной в соседа стоимости, то стоимость пути до него изменяется и меняется его родитель на текущую клетку. После рассмотрения точки - она добавляется в закрытый список. Когда открытый список исчерпан -- происходит конструирования пути, для этого мы берём родителя конечной точки и рекурсивно добавляем ей родителей в массив, пока не дойдём до начальной точки.

При написании A* для открытого списка была использована очередь с приоритетом, а для закрытого списка - вектор имеющий размер карты. Данная реализация закрытого списка дала возможность делать проверку на вхождение в него за константное время.

\subsection{Реализация алгоритма JPS}

Алгоритм JPS 

\subsection{Реализация и интеграция GoalBounds}

Алгоритм Goal Bounding можно разделить на два этапа: этап препроцессинга и проверка направления во время выполнения поиска пути. Во время препроцессинга происходит прохождение по всем клеткам карты, для каждой клетки выполняет волновой алгоритм, который заполняет все клетки стоимостью путей до них от начальной клетки и изначальным направлением по которому алгоритм пришёл в данную клетку. После чего для данной клетки определяется 8 ограничивающих прямоугольников, по одному на каждое направление \cref{fig:goal_bounding_fill}. Определяются они по такому алгоритму: 

\begin{enumerate}
	\item делаем минимальную точку прямоугольника равную координатам правой верхней точки карты, а максимальную - равной левой нижней;
	\item идём по всем точкам и расширяем прямоугольник, для направления в котором точка была достигнута, что бы прямоугольник включал её. 
\end{enumerate}

\addimg{img/goal_bounding_fill.png}{1}{Определение ограничивающих прямоугольников}{goal_bounding_fill}

Так как алгоритм вычисляет ограничивающие прямоугольники для каждой клетки независимо, то его можно распараллелить. Для этого был использован пул поток, реализованный библиотекой threadpool11. Для каждой клетки создаётся своя задача и добавляется в очередь, после добавления всех задач происходит ожидание их завершения. Каждый поток имеет свою карту для волнового алгоритма которая создаётся один раз для одного потока.

Для включения Goal Bounding в A* требуется добавить проверку на правильность направления сразу после проверки на вхождение точки в границу карты при итерировании по соседям текущей точки. 

Для добавления Goal Bouding в JPS требуется провести аналогичное действие, но для всех функций прыжков.

\subsection{Реализация визуализатора}

Для реализации визуализатора была взята кроссплатворменная библиотека SFML. Визуализатор загружает карту и отрисовывает её на текстуры, которую в последствии отображает. Пути и отладочная информация алгоритмов отрисовывается так же на текстуры и впоследствии накладывается в определённом порядке на карту. Направления для JPS алгоритма отрисовываются простыми линиями.

Для нахождения координат клетки под указателем была написана функция ``get\_tile\_under\_mouse'', которая по канвасу для отрисовки и координатам указателя находит координаты клетки. 
