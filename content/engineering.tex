\section[Проектирование программного обеспечения]{\MakeTextUppercase{ПРОЕКТИРОВАНИЕ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ}}
\vspace{-1\baselineskip} 
\subsection{Программное обеспечение}

Для написание библиотеки нахождения кратчайших путей был выбран язык программирования C++ стандарта C++11. С++ является современным языком высокого уровня, который предоставляет широкие возможности по оптимизации кода, в отличии от интерпретируемых языков и языков с JIT оптимизациями. Так же С++ широко используется в игровых приложениях. Для создания библиотеки язык С++ был выбран по следующим причинам: кроссплатформенность, быстродействие, возможность низкоуровневых оптимизаций, простота внедрения библиотеки в существующие программные продукты. 

Стандарт C++11 привнёс в язык многие функции, которые позволяют писать более понятный и современный код, уменьшить количество случайных ошибок и повысить читаемость. В следствии чего были устранены многие недостатки в сравнении с другими языками программирования.

В C++11 для измерения времени используется стандартная библиотека chrono. В chrono существует несколько реализаций измерения времени:

\begin{enumerate}
    \item system\_clock -- общесистемное время;
    \item steady\_clock -- монотонное время, которое никогда не подстраивается;
    \item high\_resolution\_clock - наиболее точное время с наименьшим доступным периодом.  
\end{enumerate} 

Для измерения времени была выбрана реализация high\_resolution\_clock.

Библиотека SFML (Simple and Fast Multimedia Library) -- кроссплатформенная библиотека для создания мультимедийных приложений. Имеет простой платформонезависимый интерфейс для рисования графики.

SFGUI - библиотека работающая совместно с библиотекой SFML и предоставляющая возможности для отрисовывания интерфейсов.

Для использования многопоточности была подключена библиотека threadpool11, которая реализует пул потоков \cite{THREAD_POOL}.

Для написания кода библиотеки была выбрана среда разработки CLion, которая имеет редактор с поддержкой синтаксиса C++11 и его подсветкой, имеет средства рефакторинга и поддерживает различные CVS, например Git. Так же имеется поддержка CMake -- системы кроссплатформенной сборки проектов, управления зависимостями и тестами.

В качестве системы контроля версий был выбран Git. Git -- распределённая система контроля версий, которая направлена на скорость работа и целостность данных, имеет гибкую и простую систему создания и объединения веток. Репозиторий проекта был размещён на удалённом сервисе BitBucket.
%
%\subsection{Архитектура ПО}

\subsection{UML-моделирование ПО}

Унифицированный язык моделирования (UML) -- язык общего назначения для визуализации, спецификации, конструирования и документации программных систем \cite{UML_USER_GUIDE_2ND}. Язык UML объединяет в себе семейство разных графических нотаций с общей метамоделью. 

Преимуществами UML являются:

\begin{enumerate}
    \item объектно-ориентированность, что делает его близким к современным объектного-ориентированным языкам;
    \item расширяем, что позволяет вводить собственные текстовые и графические стереотипы;
    \item прост для чтения;
    \item позволяет описать системы со всех точек зрения.
\end{enumerate}

В UML используется три вида диаграмм:

\begin{enumerate}
    \item структурные диаграммы -- отражают статическую структуру системы;
    \item диаграммы поведения -- отражают поведение системы в динамике, показывают, что должно происходить в системе;
    \item диаграммы взаимодействия -- подвид диаграмм поведения, которые выражают передачу контроля и данных внутри системы.
\end{enumerate} 

Для моделирования системы проектируемой в данной аттестационной работе будут использованы структурная и поведенческая диаграммы, а именно диаграмма классов (Class diagram) и диаграмма вариантов использования (Use case diagram).

Диаграмма классов является статическим отображением системы, которая демонстрирует её классы, их аттрибуты, методы и взаимосвязи. Диаграмма классов является прямым отображением классов присутствующих в системе.

Диаграмма состоит из классов и связей между ними. В свою очередь классы состоят из имени класса, его полей и методов. Поля и методы могут иметь модификаторы доступа к ним: публичный -- знак плюс, приватный -- знак минус, защищённый -- решётка и некоторые другие. Методы могут иметь аргументы и возвращаемое значение и их типы.

Связи между классами делятся на связи между созданными объектами класса и на связи на уровне самих классов. Связи между объектами включают в себя:

\begin{enumerate}
	\item зависимость -- односторонняя зависимость между двумя классами, когда изменения в одном влияют на второй;
	\item ассоциация -- набор схожих связей, которые обозначают, что один объект выполняет некоторые действия над другим, такие как: вызов метода или посылка сообщения;
	\item агрегация -- включение одним классом другого, однако при этом их жизненные циклы не зависимы;
	\item композиция -- включение одним классом другого, при этом существует зависимость между жизненным циклом контейнера и включаемого класса.
\end{enumerate}

Связи между классами делятся на:

\begin{enumerate}
	\item обобщение -- обозначает, что один из двух классов является подклассом второго;
	\item реализация -- обозначает, что класс реализует поведение определённое во втором.
\end{enumerate}

В разрабатываемой библиотеки можно выделить центральный интерфейс, который является основным интерфейсом для взаимодействия с ней, это PathFinder \cref{fig:diagram_classes}. Он является шаблонным классом и параметризуется типом координат (целочисленный тип), он имеет один метод -- Find, который принимает начальную позицию, конечную позицию и тип актёра (проходимость актёра), а возвращает вектор клеток являющихся найденным маршрутом. Его реализуют классы SimpleAStar и JPSAstar, которые в свою очередь имеют следующие шаблонные параметры: тип карты, эвристика, включение Goal Bounding и включение режима отладки.  

\addimg{path_finding_classes.png}{1.1}{Диаграмма классов}{diagram_classes}

Интерфейс для реализации эвристика, Heuristic, содержит метод nodes\_distance, который принимает текущую точку, конечную точку и начальную точку, а возвращает приближённо оценённую стоимость маршрута от текущей до конечной точки. Эвристика включается в PathFinder как шаблонный класс.

Класс GoalBounding реализует одноимённый алгоритм и содержит методы для препроцессинга карты с заданным типом актёра, для загрузки и сохранения информации полученный при препроцессинге, а так же для отброса направлений при поиске пути. Данный класс включается в класс карты и используется в классах реализующих PathFinder.

Класс карты является базовой реализацией карты и содержит методы для получение данных о препроцессинге, размеров картыб проверки вхождения точки в область карты и метод получения клетки карты. Класс карты передаётся в PathFinder через конструктор и хранится в нём. Карта включает в отдельные клетки MapNode, которые имеют вес, проходимость и метод для проверки на проходимость.

Карта загружается по средством класса MapLoader, который имеет единственный метод для загрузки карты по её имени.

Диаграмма вариантов использования позволяет отразить представленную систему в динамике, а именно собрать требования к системе отражающие внешние и внутренние воздействия. Она позволяет показать взаимодействие различных пользователей и частей системы. Целями диаграммы вариантов являются:

\begin{enumerate}
	\item сбор требований к системе;
	\item получение вида системы со стороны;
	\item идентификация внутренних и внешних воздействий на систему;
	\item показ взаимодействия требований и актёров.
\end{enumerate}

Диаграмма вариантов использования состоит из вариантов использования, которые представляют собой некоторую высокоуровневую функцию системы определённую через анализ требований, актёров, которые являются чем-то, что взаимодействует с системой и связей между вариантами использования и актёрами \cite{USE_CASE}.

Актёром может быть как человек или организация, которая использует систему, так и внешний сервис взаимодействующий с ней. Графически актёр обычно представляется в виде человечка.

Взаимодействие актёра и варианта использования отражается посредством стрелки между ними.

При создании варианта использования стоит уделять внимание выбору его имени. Оно должно чётко определять выполняемую функцию и начинаться с глагола. 

Варианты использования могут включать другие и расширять их. Варианты использования создаются и рисуются от самых крупных уровней к самым мелким.

В разрабатываемой библиотеки можно выделить программиста, который использует её, как актёра. В свою очередь как варианты использования можно выделить части упрощённого интерфейса библиотеки \cref{fig:diagram_use_case}, что даёт нам три варианта использования: 

\begin{enumerate}
	\item ``Выполнить препроцессинг'' карты;
	\item ``Найти путь'', который реализован двумя разными алгоритмами и может быть расширен с помощью Goal Bounding алгоритма;
	\item ``Загрузить карту'', который реализован в виде загрузки простой текстовой карты.
\end{enumerate}

\addimg{path_finding_use_case.png}{0.75}{Диаграмма Use case}{diagram_use_case}

\subsection{Требования к ПО}

Библиотека должна предоставлять интерфейс для нахождения путей различными алгоритмами с поддержкой:

\begin{enumerate}
	\item различных реализаций карт;
	\item различных эвристик;
	\item включения и выключения Goal Bounding алгоритма;
	\item возможностью опционально получить информацию для отладки алгоритмов.
\end{enumerate}

Должен иметься интерфейс для работы с Goal Bounding алгоритмом включающий в себя: препроцессинг карты, сохранение и загрузка результатов.

Так же библиотека должна предоставлять базовую реализацию карты и её загрузчика.

Библиотека должна зависить только от стандартной библиотеки и библиотеки threadpool11.

Библиотека не должна включать платформозависимый код и в следствии чего должна компилироваться на различных платформах, таких как: x32, x86-64, arm.

Библиотека должна иметь простой способ включения в другие проекты.   

\subsection{Описание интерфейса взаимодействия с библиотекой}

Для работы с библиотекой требуется её включение в проект по средством CMake или её подключение в бинарном виде. 

Основным интерфейсом взаимодействия с библиотекой является интерфейс нахождения путей PathFinder<CoordsType> \cref{fig:path_finding_interface}, который имеет метод find с аргументами начальной, конечной точки и типа актёра (его проходимость), а возвращать массив точек представляющих собой найденный маршрут.

\addimg{img/path_finding_interface.png}{0.85}{Интерфейс нахождения путей}{path_finding_interface}

Так же предоставляется интерфейс для модификации работы алгоритмов (типа карты, эвристики, Goal Bounding) посредством шаблонов. Из-за того, что количество параметров шаблонов большое, библиотекой предоставляется несколько предзаданных вариантов.

Библиотекой предоставляется интерфейс и реализация базовой версии карты, который включает в себя загрузку карты, получение её параметров и отдельных клеток, а так же выполнение препроцессинга Goal Bounding.   
