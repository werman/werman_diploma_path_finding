\section[Проектирование программного обеспечения]{\MakeTextUppercase{ПРОЕКТИРОВАНИЕ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ}}
\vspace{-1\baselineskip} 
\subsection{Программное обеспечение}

Для написание библиотеки нахождения кратчайших путей был выбран язык программирования C++ стандарта C++11. С++ является современным языком высокого уровня, который предоставляет широкие возможности по оптимизации кода, в отличии от интерпретируемых языков и языков с JIT оптимизациями. Так же С++ широко используется в игровых приложениях. Для создания библиотеки язык С++ был выбран по следующим причинам: кроссплатформенность, быстродействие, возможность низкоуровневых оптимизаций, простота внедрения библиотеки в существующие программные продукты. 

Стандарт C++11 привнёс в язык многие функции, которые позволяют писать более понятный и современный код, уменьшить количество случайных ошибок и повысить читаемость. В следствии чего были устранены многие недостатки в сравнении с другими языками программирования.

В C++11 для измерения времени используется стандартная библиотека chrono. В chrono существует несколько реализаций измерения времени:

\begin{enumerate}
    \item system\_clock -- общесистемное время;
    \item steady\_clock -- монотонное время, которое никогда не подстраивается;
    \item high\_resolution\_clock - наиболее точное время с наименьшим доступным периодом.  
\end{enumerate} 

Для измерения времени была выбрана реализация high\_resolution\_clock.

Библиотека SFML (Simple and Fast Multimedia Library) -- кроссплатформенная библиотека для создания мультимедийных приложений. Имеет простой платформонезависимый интерфейс для рисования графики.

SFGUI - библиотека работающая совместно с библиотекой SFML и предоставляющая возможности для отрисовывания интерфейсов.

Для использования многопоточности была подключена библиотека threadpool11, которая реализует пул потоков \cite{THREAD_POOL}.

Для написания кода библиотеки была выбрана среда разработки CLion, которая имеет редактор с поддержкой синтаксиса C++11 и его подсветкой, имеет средства рефакторинга и поддерживает различные CVS, например Git. Так же имеется поддержка CMake -- системы кроссплатформенной сборки проектов, управления зависимостями и тестами.

В качестве системы контроля версий был выбран Git. Git -- распределённая система контроля версий, которая направлена на скорость работа и целостность данных, имеет гибкую и простую систему создания и объединения веток. Git репозиторий проекта был размещён на удалённом сервисе BitBucket.

\subsection{UML-моделирование ПО}

Унифицированный язык моделирования (UML) -- язык общего назначения для визуализации, спецификации, конструирования и документации программных систем \cite{UML_USER_GUIDE_2ND}. Язык UML объединяет в себе семейство разных графических нотаций с общей метамоделью. 

Преимуществами UML являются:

\begin{enumerate}
    \item объектно-ориентированность, что делает его близким к современным объектного-ориентированным языкам;
    \item расширяем, что позволяет вводить собственные текстовые и графические стереотипы;
    \item прост для чтения;
    \item позволяет описать системы со всех точек зрения.
\end{enumerate}

В UML используется три вида диаграмм:

\begin{enumerate}
    \item структурные диаграммы -- отражают статическую структуру системы;
    \item диаграммы поведения -- отражают поведение системы в динамике, показывают, что должно происходить в системе;
    \item диаграммы взаимодействия -- подвид диаграмм поведения, которые выражают передачу контроля и данных внутри системы.
\end{enumerate} 

Для моделирования системы проектируемой в данной аттестационной работе будут использованы структурная и поведенческая диаграммы, а именно диаграмма классов (Class diagram) и диаграмма вариантов использования (Use case diagram).

Диаграмма классов является статическим отображением системы, которая демонстрирует её классы, их аттрибуты, методы и взаимосвязи. Диаграмма классов является прямым отображением классов присутствующих в системе.

Диаграмма состоит из классов и связей между ними. В свою очередь классы состоят из имени класса, его полей и методов. Поля и методы могут иметь модификаторы доступа к ним: публичный -- знак плюс, приватный -- знак минус, защищённый -- решётка и некоторые другие. Методы могут иметь аргументы и возвращаемое значение и их типы.

Связи между классами делятся на связи между созданными объектами класса и на связи на уровне самих классов. Связи между объектами включают в себя:

\begin{enumerate}
	\item зависимость -- односторонняя зависимость между двумя классами, когда изменения в одном влияют на второй;
	\item ассоциация -- набор схожих связей, которые обозначают, что один объект выполняет некоторые действия над другим, такие как: вызов метода или посылка сообщения;
	\item агрегация -- включение одним классом другого, однако при этом их жизненные циклы не зависимы;
	\item композиция -- включение одним классом другого, при этом существует зависимость между жизненным циклом контейнера и включаемого класса.
\end{enumerate}

Связи между классами делятся на:

\begin{enumerate}
	\item обобщение -- обозначает, что один из двух классов является подклассом второго;
	\item реализация -- обозначает, что класс реализует поведение определённое во втором.
\end{enumerate}

В разрабатываемой библиотеки можно выделить центральный интерфейс, который является основным интерфейсом для взаимодействия с ней, это PathFinder \cref{fig:diagram_classes}. Он является шаблонным классом и параметризуется типом координат (целочисленный тип), он имеет один метод -- Find, который принимает начальную позицию, конечную позицию и тип актёра (проходимость актёра), а возвращает вектор клеток являющихся найденным маршрутом. Его реализуют классы SimpleAStar и JPSAstar, которые в свою очередь имеют следующие шаблонные параметры: тип карты, эвристика, включение Goal Bounding и включение режима отладки.  

\addimg{path_finding_classes.png}{1.1}{Диаграмма классов}{diagram_classes}

Интерфейс для реализации эвристики, Heuristic, содержит метод nodes\_distance, который принимает текущую точку, конечную точку и начальную точку, а возвращает приближённо оценённую стоимость маршрута от текущей до конечной точки. Эвристика включается в PathFinder как шаблонный класс.

Класс GoalBounding реализует одноимённый алгоритм и содержит методы для препроцессинга карты с заданным типом актёра, для загрузки и сохранения информации полученный при препроцессинге, а так же для отброса направлений при поиске пути. Данный класс включается в класс карты и используется в классах реализующих PathFinder.

Класс карты является базовой реализацией карты и содержит методы для получение данных о препроцессинге, размеров карты, проверки вхождения точки в область карты и метод получения клетки карты. Класс карты передаётся в PathFinder через конструктор и хранится в нём. Карта включает в отдельные клетки MapNode, которые имеют вес, проходимость и метод для проверки на проходимость.

Карта загружается по средством класса MapLoader, который имеет единственный метод для загрузки карты по её имени.

Диаграмма вариантов использования позволяет отразить представленную систему в динамике, а именно собрать требования к системе отражающие внешние и внутренние воздействия. Она позволяет показать взаимодействие различных пользователей и частей системы. Целями диаграммы вариантов являются:

\begin{enumerate}
	\item сбор требований к системе;
	\item получение вида системы со стороны;
	\item идентификация внутренних и внешних воздействий на систему;
	\item показ взаимодействия требований и актёров.
\end{enumerate}

Диаграмма вариантов использования состоит из вариантов использования, которые представляют собой некоторую высокоуровневую функцию системы определённую через анализ требований, актёров, которые являются чем-то, что взаимодействует с системой и связей между вариантами использования и актёрами \cite{USE_CASE}.

Актёром может быть как человек или организация, которая использует систему, так и внешний сервис взаимодействующий с ней. Графически актёр обычно представляется в виде человечка.

Взаимодействие актёра и варианта использования отражается посредством стрелки между ними.

При создании варианта использования стоит уделять внимание выбору его имени. Оно должно чётко определять выполняемую функцию и начинаться с глагола. 

Варианты использования могут включать другие и расширять их. Варианты использования создаются и рисуются от самых крупных уровней к самым мелким.

В разрабатываемой библиотеки можно выделить программиста, который использует её, как актёра. В свою очередь как варианты использования можно выделить части упрощённого интерфейса библиотеки \cref{fig:diagram_use_case}, что даёт нам три варианта использования: 

\begin{enumerate}
	\item ``Выполнить препроцессинг'' карты;
	\item ``Найти путь'', который реализован двумя разными алгоритмами и может быть расширен с помощью Goal Bounding алгоритма;
	\item ``Загрузить карту'', который реализован в виде загрузки простой текстовой карты.
\end{enumerate}

\addimg{path_finding_use_case.png}{0.8}{Диаграмма Use case}{diagram_use_case}

\subsection{Требования к ПО}

Библиотека должна предоставлять интерфейс для нахождения путей различными алгоритмами с поддержкой:

\begin{enumerate}
    \item одного универсального интерфейса для всех алгоритмов; 
	\item различных реализаций карт;
	\item различных эвристик;
	\item включения и выключения Goal Bounding алгоритма;
	\item возможностью опционально получить информацию для отладки алгоритмов.
\end{enumerate}

Поддержка различных реализаций карт и эвристик должна осуществляться посредством задания их типов как шаблонов, при этом такие реализации должны иметь определённые алгоритмом методы для доступа к их информации.

Должен иметься интерфейс для работы с Goal Bounding алгоритмом включающий в себя: препроцессинг карты, сохранение и загрузка результатов.

Так же библиотека должна предоставлять базовую реализацию карты и её загрузчика.

Библиотека должна зависеть только от стандартной библиотеки и библиотеки threadpool11.

Библиотека не должна включать платформозависимый код и в следствии чего должна компилироваться на различных платформах, таких как: x32, x86-64, arm. 

Библиотека должна иметь простой способ включения в другие проекты.   

\subsection{Описание интерфейса взаимодействия с библиотекой}

Для работы с библиотекой требуется её включение в проект по средством CMake или её подключение в бинарном виде. 

CMake - расширяемая система с открытым исходным кодом, которая управляет процессом сборки не зависимо от целевого компилятора. В отличии от других кроссплатформных систем, CMake работает совместно с родными для компиляторов окружениями сборки. В следствии чего CMake генерирует стандартные файлы для сборки для каждого конкретного компилятора. Так же CMake имеет гибкую систему настроек, что позволяет создавать множество целей сборки, которые могут зависеть от разных условий, например платформы на которой происходит компиляция.

Основным интерфейсом взаимодействия с библиотекой является интерфейс нахождения путей PathFinder<CoordsType> \cref{fig:path_finding_interface}, который имеет метод find с аргументами начальной, конечной точки и типа актёра (его проходимость), а возвращает массив точек представляющих собой найденный маршрут, где первый элемент -- это начальная точка, а последний -- конечная.

\begin{figure}[!htb]
	\centering
	\captionsetup{justification=centering}
	\begin{lstlisting}
template<class CoordsType>
class PathFinder
{
public:
virtual std::vector<Point<CoordsType>> find( CoordsType startX, 
					CoordsType startY,
					CoordsType targetX,
					CoordsType targetY,
					uint32_t unitType ) = 0;
};
	\end{lstlisting}
	\caption{Интерфейс нахождения путей}
	\label{fig:path_finding_interface}
\end{figure}

Так же предоставляется интерфейс для модификации работы алгоритмов (типа карты, эвристики, Goal Bounding) посредством шаблонов. Из-за того, что количество параметров шаблонов большое, библиотекой предоставляется несколько заданных вариантов: ``AStar16'', ``AStar16GoalBounded'', ``JPSAStar16'', ``JPSAStar16GBound'', ``JPSAStar16Dbg'', ``JPSAStar16GBoundDbg''.

Интерфейс карты для корректной работы с алгоритмами должен иметь следующие методы:

\begin{enumerate}
	\item ``GetNode'', который по координатам возвращает информацию о точке;
	\item ``IsXOnMap'' и ``IsYOnMap'', которые проверяют точки на вхождение в границу карты;
	\item ``IsPassable'', которая проверяет является ли переданная точка проходимой для переданного типа актёра;
	\item ``IsPassableXSafe'' и ``IsPassableYSafe'', которые при проверке на проходимость -- так же проверяют находится ли точка в границах карты; 
\end{enumerate}

В свою очередь объект возвращаемые ``GetNode'' должен иметь методы для определения возможности пройти через клетку ``IsPassable'' и стоимости прохождения ``GetWeight''.

Эвристика для корректной работы должна иметь статичный метод ``nodes\_distance'', который принимает координаты текущей, конечной точки и начальной точки (начальная точка требуется для некоторых эвристик, хотя в большинстве и не используется).

Библиотекой предоставляется интерфейс и реализация базовой версии карты, который включает в себя загрузку карты, получение её параметров и отдельных клеток, а так же выполнение препроцессинга Goal Bounding.   
